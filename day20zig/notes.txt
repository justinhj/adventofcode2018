First is how to parse the regex. You could parse it into an AST. 

^ENWWW(NEEE|SSE(EE|N))$

Which would be

East, North, West, West, West, 
  ChoiceOf
     North, East, East East
     South South East ChoiceOf
        East East 
        North 

But while generating the AST you could just be walking and producing the map.

Map format?

Options... 

Could be a 2d array. Efficient and easy to move about. Starts with ?.
  Tricky because size is unknown so you need to make it large and start in the middle and possibly
  have to do over.

Or a graph. A bit less efficient due to pointer chasing but at least the right size. Hard to draw?
  Each node can contain the X,Y coordinates which you can simply generate as you go.
  Then when you draw it start by finding the bounds.

TODO 

1. Generate the graph including the coordinates.
2. Make a draw function.

algorithm

0 1 2 3 4 5 6 7 9 9 1 b c d e f
n n n ( w w w | e e e | ) n n n 

you can loop until you hit (
when you hit (
  get the list of indexes of | and the ) (taking into account nested options)
  for each index 
    execute from that index 
    iff there is an empty option also execute from after the )

in above the main loop hits 0 1 2 at 3 sees the (
calculate the indexes gives 4, 9 and d at depth 1

a) traverse from 4 d1
b) from 9 d1
c) from d d0

a) w w w (when we hit | it means we skip to the end of the option to d and then n n n 
b) e e e | skip to d 
c) skip to d

so two parameters to traverse are usize depth (to calculate nested options), optional skip destination, 


0 1 2 3 4 5 6 7 9 9 1 b c d e f
n n n ( w w w | e e e | ) n n n 


n n n ( (set depth to 1) set mode to skip until next ) at this depth. if you see |) then continue otherwise stop


   
