First is how to parse the regex. You could parse it into an AST. 

^ENWWW(NEEE|SSE(EE|N))$

Which would be

East, North, West, West, West, 
  ChoiceOf
     North, East, East East
     South South East ChoiceOf
        East East 
        North 

But while generating the AST you could just be walking and producing the map.

Map format?

Options... 

Could be a 2d array. Efficient and easy to move about. Starts with ?.
  Tricky because size is unknown so you need to make it large and start in the middle and possibly
  have to do over.

Or a graph. A bit less efficient due to pointer chasing but at least the right size. Hard to draw?
  Each node can contain the X,Y coordinates which you can simply generate as you go.
  Then when you draw it start by finding the bounds.

TODO 

1. Generate the graph including the coordinates.
2. Make a draw function.

algorithm

0 1 2 3 4 5 6 7 9 9 1 b c d e f
n n n ( w w w | e e e | ) n n n 

you can loop until you hit (
when you hit (
  get the list of indexes of | and the ) (taking into account nested options)
  for each index 
    execute from that index 
    iff there is an empty option also execute from after the )

in above the main loop hits 0 1 2 at 3 sees the (
calculate the indexes gives 4, 9 and d at depth 1

a) traverse from 4 d1
b) from 9 d1
c) from d d0

a) w w w (when we hit | it means we skip to the end of the option to d and then n n n 
b) e e e | skip to d 
c) skip to d

so two parameters to traverse are usize depth (to calculate nested options), optional skip destination, 


0 1 2 3 4 5 6 7 9 9 1 b c d e f
n n n ( w w w | e e e | ) n n n 


n n n ( (set depth to 1) set mode to skip until next ) at this depth. if you see |) then continue otherwise stop

Update.

What expand should do?

Current arguments.

fn expand(map: *Map, current_pos: Pos, regex: []const u8, regex_start: usize, direction: Direction) !void

Expand has no return value. It's job is to expand the map. It is not recursive.

It should start by taking the next element from the regex and decide what to do.

1. NSEW it should create a door and a floor in the direction, return an error if the bounds are exceeded.
2. ^ it can just advance. $ it must stop.
3. ( it should do the following:

a) with awareness of nesting create an array of the start and endpoints of each section and the last brace
b) for each start point it should start a new explore with regex_start at that position. it should continue until it hits | and then jump to the last brace and continue from there
c) care is needed to handle the last section is empty (you immediately see a )) 

Change plan.

Add a new argument for the last brace location (optional)
It's probably okay to assume that if you hit a | you were supposed to. Can assert that brace location is set.

Write the function that takes the regex position at the (
it should handle nesting and generate and return a list of start poiunts and the endpoint

Remove the logic that handles direction as a param.




